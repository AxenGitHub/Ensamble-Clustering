{
    "contents" : "###currently not working, fix the Wald algorithm first###\n## v0.4 works but the Wald algorithm has not been implemented there###\n\nlibrary(cluster.datasets)\nlibrary(skmeans) #spherical kmeans package\nlibrary(mclust) #Expectation Maximization package\n\n#approach:\n#user can define the number of iterations for the clustering algorithm\n#and if to change the number of clusters at each iteration to simualte different clustering solutions\n#in order to do so, change the chCl flag to TRUE and set the minimum number of clusters to start from\n#the max number of clusters will be the one specified in numCl\n#choose between spherical or euclidean clusterting algorithm\n#choose if to standardize or not the dataset\n\n#steps:\n#generate consensus matrix\n#introduce drop tolerance (less than 10% of the times items are clustered together, set the correlation to 0)\n#markov chain? divide rows by their sum?\n#run principal component analysis -> extract eigenvalues\n#plot eighenvalues to determine the number of clusters  -> the ones closer to 1 before a gap should represent the \"right\" number of clusters\n#run ensemble clustering on the consensus matrix multiple times to refine and ultimately determine the \"right\" amount of clusters in the data\n\n#webpage describing clustering algorithm implemented in the cluster package\n#http://cran.r-project.org/web/views/Cluster.html\n\n#v0.4\n#introducing clustering algorithm Expectation Maximization (using all default values except for the number of clusters)\n#http://en.wikibooks.org/wiki/Data_Mining_Algorithms_In_R/Clustering/Expectation_Maximization_(EM)\n\n#v0.5\n#added Ward algorighm. It is a hierarchical method, it is computationally heavy, comment it for better performance of the program\n\n########################################\n# Set up global variables\n#######################################\n\n#max number of clusters\nnumCl_global = 14\n#number of runs of kmeans algorithm with different seeds\nnumIter_global = 20\n#random number generator boundaries\nminRan = 1\nmaxRan = 10000\n\n#Tolerance: minimum percentage of times items needs to be clustered together to be considered,\n#if the number is below tolerance, their correlation will be set to 0\ntol_global = 0.20\n\n#control if the algorithm runs with the same number of clusters if the number of clusters changes at each iteration\n#TRUE - FALSE\nchgCl_global = TRUE\n#min number of clusters to start from if chgCl is set to TRUE\nminCl_global = 4\n\n#use spherical kmeans, if FALSE, eucledian kmeans is used\nsphere_global = TRUE\n\n#standardize dataset, if TRUE, standardization is applied (not the ranged one, the variance one)\nstd_global = FALSE\n\n#If TRUE, Wald clustering is enabled, if FALSE, it is disabled \nwald_alg = TRUE\n#######################################\n# Define functions \n#######################################\n\n#Generate first consensus matrix from original dataset\n#parameter: \n#dataset: the dataset to analyze in matrix format\n#datasetName: the name of the dataset to use in the plot, by default is null\n#all the other parameters are a replica of the global parameter\nDatasetAnalysis <- function(dataset, datasetName=NULL, chgCl=chgCl_global, minCl=minCl_global, numCl=numCl_global, numIter=numIter_global, std=std_global, sphere=sphere_global, tol=tol_global){\n  #set the minimum number of clusters to the max number of clusters in order to execute only once the internal do-loop\n  if(chgCl == FALSE){\n    minCl = numCl\n  }\n  \n  if(std == TRUE){\n    dataset <- scale(dataset,center=FALSE,scale=TRUE)\n  }\n  \n  #if skemans is requested, remove the rows and columns that sum up to zero, otherwise the skemans function won't work\n  if(sphere == TRUE){\n    #dataset <- as.matrix(dataset)\n    dataset <- dataset[rowSums(dataset) != 0, colSums(dataset) != 0]\n  }\n  \n  if (wald_alg == TRUE){\n    wald_distance <- dist(dataset, method = \"euclidean\") # distance matrix\n  }\n\n#un-comment the dataset to analyze, comment the others\n#   if(std == TRUE){\n#     dataset <- scale(dataset,center=FALSE,scale=TRUE)\n#   }\n\n  #run the k-means cluster numIter times and each time initialize the seed with a random number\n  #if instead, the flag to change the number of clusters is active, minCl will be set to the user value and the number of iterations will change.\n  for (iter in 1:numIter){\n    \n    #set seed\n    set.seed(sample(minRan:maxRan,1))\n    #run kmeans algorithm \n    \n    \n    for (currNumCl in minCl:numCl){\n      ###################\n      #kmeans\n      ###################\n      #print(\"kmeans\")\n      if (sphere == TRUE){\n        cl <- skmeans(dataset, currNumCl, method='pclust', control=list(verbose=FALSE))\n      }else{\n        cl <- kmeans(dataset, currNumCl)\n      }\n      \n      #generate consensus matrix - for kmeans\n      for (i in 1:currNumCl){\n        #(cl$cluster == i)  returns TRUE for each element that is part of cluster i, FALSE otherwise\n        #for the consensus matrix, we need ones and zeros, the +0 trick transforms TRUE in 1s and FALSE in 0\n        clVector <- (cl$cluster == i) + 0\n        #print(paste(\"kmeans vector size \", length(clVector)))\n        #generate consensus matrix for current cluster\n        consMatrixCl <- clVector %*% t(clVector)\n        \n        #if it's the first cluster of the first iteration, there is no general consensus matrix yet, the cluster consensus matrix is also the general one\n        if(iter==1 && i==1){\n          consMatrixAlg <- consMatrixCl\n        }else{\n          #from the second cluster onward, sum cluster consensus matrices to the general one\n          consMatrixAlg <- consMatrixAlg + consMatrixCl\n        }\n      }\n       \n      ###################\n      #Expectation Maximization Clustering\n      ###################\n      #print(\"EM\")\n      #run the expectation maximization clustering algorithm, setting the number of cluster G to the current number of clusters to be analyzed\n      cl <- Mclust(dataset, G=currNumCl)\n      \n      #cl$n contains the number of rows of the matrix, the number of observations\n      #cl$z is the matrix containing the probability that each observation (row) has to belong to each cluster (column)\n      #the approach is to assign each observation to the clusters it has highest probability of belonging to\n      for (i in 1:cl$n){\n        maxVal <- max(cl$z[i,])\n        cl$z[i,] <- (cl$z[i,] == maxVal)+0\n      }\n      \n      #generate consensus matrix - for Expectation Maximization Clustering\n      for (i in 1:currNumCl){\n        #in cl$z each column represent the cluster vector\n        clVector <- cl$z[,i]\n        #print(paste(\"EM vector size \", length(clVector)))\n        #generate consensus matrix for current cluster\n        consMatrixCl <- clVector %*% t(clVector)\n        #print(paste(\"EM dimension consMatrixCl \", dim(consMatrixCl)))\n        #print(paste(\"EM dimension consMatrixAlg \", dim(consMatrixAlg)))     \n        #since this is run after the first kmeans algorithm, we are sure that the Consensus Matrix has already been created\n        consMatrixAlg <- consMatrixAlg + consMatrixCl\n      }\n      \n      ###################\n      #Ward Clustering\n      ###################\n      #print(\"Ward\")\n      if (wald_alg == TRUE){\n        # Ward Hierarchical Clustering\n        fit <- hclust(wald_distance, method=\"ward.D2\") \n        #plot(fit) # display dendogram\n        cl <- cutree(fit, k=currNumCl) # cut tree into currNumCl clusters\n        \n        #generate consensus matrix - for Expectation Maximization Clustering\n        for (i in 1:currNumCl){\n          #each entry in the cl vector indicates which cluster the corrisponding row belongs to.\n          clVector <- (cl == i) + 0\n          #generate consensus matrix for current cluster\n          consMatrixCl <- clVector %*% t(clVector)\n          #since this is run after the first kmeans algorithm, we are sure that the Consensus Matrix has already been created\n          consMatrixAlg <- consMatrixAlg + consMatrixCl\n        }\n      }\n    }\n  }\n  \n  \n  #free unnecessary memory\n  remove(clVector,consMatrixCl, wald_distance)\n  \n  #determine the minimum number of times items need to be clustered together to be considered valid clustering solutions\n  #use the ceiling function to determine the first smallest integer above the tolerance limit\n  if(chgCl==FALSE){\n    minNumCl <- ceiling(numIter * tol)\n  }else{\n    minNumCl <- ceiling(numIter * minCl * tol)\n  }\n  #apply tolerance filtering only if it is above 1, otherwise it is an uneccessary waste of computational time\n  #invisible is used to avoid printing the entire matrix after the values are replaced\n  if (minNumCl > 1){\n    invisible(replace(consMatrixAlg, consMatrixAlg < minNumCl, 0))\n  }\n  \n  #divide each row by its row sum (Markov Chain appraoch)\n  consMatrixAlg <- consMatrixAlg/rowSums(consMatrixAlg)\n  \n  #calculate eigenvalues for the consensus matrix\n  #only.values -> we care only about the eigenvalues here.\n  evalues <- eigen(consMatrixAlg, symmetric=TRUE,only.values=TRUE)\n  \n  if(chgCl==TRUE){\n    title <- paste(\"Analysis on Dataset \",datasetName,\"\\n chgCl=\",chgCl,\" minCl=\",minCl,\"numCl=\",numCl,\" numIter=\",numIter,\"\\n Sphere=\",sphere,\"\\n Wald=\",wald_alg,\" Std=\",std)\n  }else{\n    title <- paste(\"Analysis on Dataset \",datasetName,\"\\n chgCl=\",chgCl,\"numCl=\",numCl,\" numIter=\",numIter,\"\\n Sphere=\",sphere,\"\\n Wald=\",wald_alg,\" Std=\",std)\n  }\n  plot(evalues$values[1:numCl], main=title)\n  return (consMatrixAlg)\n}\n\n\n# #analyze data with principal\n# #is it necessary to center the data?\n# #svddata<-svd(scale(consMatrixAlg,center=TRUE,scale=FALSE))\n# \n# #should we even do a SVD or we just need the eigenvalues for this?\n# svddata<-svd(consMatrixAlg)\n# plot(svddata$d)\n# \n# #PCA does not work for this matrix, it is sparse\n# pcadata <-prcomp(consMatrixAlg)\n\n\n\n\n#Run algorithm on consensus matix\n#parameter: \n#datasetName: the name of the dataset to use in the plot, by default is null\n#all the other parameters are a replica of the global parameter\n\nConsensusMatrixAnalysis <- function(datasetName=NULL, chgCl=chgCl_global, minCl=minCl_global, numCl=numCl_global, numIter=numIter_global, sphere=sphere_global, tol=tol_global){\n  #set the minimum number of clusters to the max number of clusters in order to execute only once the internal do-loop\n  if(chgCl == FALSE){\n    minCl = numCl\n  }\n  \n  if (wald_alg == TRUE){\n    wald_distance <- dist(consMatrixAlg, method = \"euclidean\") # distance matrix\n  }\n  \n  for (iter in 1:numIter){ \n    #set seed\n    set.seed(sample(minRan:maxRan,1))\n    #run kmeans algorithm \n    \n    for (currNumCl in minCl:numCl){\n      if (sphere == TRUE){\n        cl <- skmeans(consMatrixAlg, currNumCl, method='pclust', control=list(verbose=FALSE))\n      }else{\n        cl <- kmeans(consMatrixAlg, currNumCl)\n      }\n\n      #generate consensus matrix\n      for (i in 1:currNumCl){\n        #(cl$cluster == i)  returns TRUE for each element that is part of cluster i, FALSE otherwise\n        #for the consensus matrix, we need ones and zeros, the +0 trick transforms TRUE in 1s and FALSE in 0\n        clVector <- (cl$cluster == i) + 0\n        #generate consensus matrix for current cluster\n        consMatrixCl <- clVector %*% t(clVector)\n        \n        #if it's the first cluster of the first iteration, there is no general consensus matrix yet, the cluster consensus matrix is also the general one\n        if(iter==1 && i==1){\n          consMatrixAlg2 <- consMatrixCl\n        }else{\n          #from the second cluster onward, sum cluster consensus matrices to the general one\n          consMatrixAlg2 <- consMatrixAlg2 + consMatrixCl\n        }\n      }\n      \n      ###################\n      #Expectation Maximization Clustering\n      ###################\n      #print(\"EM\")\n      #run the expectation maximization clustering algorithm, setting the number of cluster G to the current number of clusters to be analyzed\n      cl <- Mclust(consMatrixAlg, G=currNumCl, maxRan=100)\n      \n      #cl$n contains the number of rows of the matrix, the number of observations\n      #cl$z is the matrix containing the probability that each observation (row) has to belong to each cluster (column)\n      #the approach is to assign each observation to the clusters it has highest probability of belonging to\n      for (i in 1:cl$n){\n        maxVal <- max(cl$z[i,])\n        cl$z[i,] <- (cl$z[i,] == maxVal)+0\n      }\n      \n      #generate consensus matrix - for Expectation Maximization Clustering\n      for (i in 1:currNumCl){\n        #in cl$z each column represent the cluster vector\n        clVector <- cl$z[,i]\n        #print(paste(\"EM vector size \", length(clVector)))\n        #generate consensus matrix for current cluster\n        consMatrixCl <- clVector %*% t(clVector)\n        #print(paste(\"EM dimension consMatrixCl \", dim(consMatrixCl)))\n        #print(paste(\"EM dimension consMatrixAlg \", dim(consMatrixAlg)))     \n        #since this is run after the first kmeans algorithm, we are sure that the Consensus Matrix has already been created\n        consMatrixAlg2 <- consMatrixAlg2 + consMatrixCl\n      }     \n      \n      ###################\n      #Ward Clustering\n      ###################\n      #print(\"Ward\")\n      if (wald_alg == TRUE){\n        # Ward Hierarchical Clustering\n        fit <- hclust(wald_distance, method=\"ward.D2\") \n        #plot(fit) # display dendogram\n        cl <- cutree(fit, k=currNumCl) # cut tree into currNumCl clusters\n        \n        #generate consensus matrix - for Expectation Maximization Clustering\n        for (i in 1:currNumCl){\n          #each entry in the cl vector indicates which cluster the corrisponding row belongs to.\n          clVector <- (cl == i) + 0\n          #generate consensus matrix for current cluster\n          consMatrixCl <- clVector %*% t(clVector)\n          #since this is run after the first kmeans algorithm, we are sure that the Consensus Matrix has already been created\n          consMatrixAlg2 <- consMatrixAlg2 + consMatrixCl\n        }\n      }\n      \n    }\n  }\n  \n  consMatrixAlg <- consMatrixAlg2\n  #free unecessary memory\n  remove(clVector,consMatrixCl, consMatrixAlg2, wald_distance)\n  \n  #determine the minimum number of times items need to be clustered together to be considered valid clustering solutions\n  #use the ceiling function to determine the first smallest integer above the tolerance limit\n  if(chgCl==FALSE){\n    minNumCl <- ceiling(numIter * tol)\n  }else{\n    minNumCl <- ceiling(numIter * minCl * tol)\n  }\n\n  #apply tolerance filtering only if it is above 1, otherwise it is an uneccessary waste of computational time\n  #invisible is used to avoid printing the entire matrix after the values are replaced\n  if (minNumCl > 1){\n    invisible(replace(consMatrixAlg, consMatrixAlg < minNumCl, 0))\n  }\n  \n  #divide each row by its row sum (Markov Chain appraoch) \n  consMatrixAlg <- consMatrixAlg/rowSums(consMatrixAlg)\n  \n  #calculate eigenvalues for the consensus matrix\n  #only.values -> we care only about the eigenvalues here.\n  evalues <- eigen(consMatrixAlg, symmetric=TRUE,only.values=TRUE)\n  if (is.null(datasetName) == TRUE){\n    if(chgCl==TRUE){\n      title <- paste(\"Analysis on Consensus Matrix \\n chgCl=\",chgCl,\" minCl=\",minCl,\"numCl=\",numCl,\" numIter=\",numIter,\"\\n Sphere=\",sphere,\" Std=\",std)\n    }else{\n      title <- paste(\"Analysis on Consensus Matrix \\n chgCl=\",chgCl,\"numCl=\",numCl,\" numIter=\",numIter,\"\\n Sphere=\",sphere,\" Std=\",std)\n    }\n  }else{\n    if(chgCl==TRUE){\n      title <- paste(\"Dataset: \",datasetName,\"\\n Analysis on Consensus Matrix \\n chgCl=\",chgCl,\" minCl=\",minCl,\"numCl=\",numCl,\" numIter=\",numIter,\"\\n Sphere=\",sphere)\n    }else{\n      title <- paste(\"Dataset: \",datasetName,\"\\n Analysis on Consensus Matrix \\n chgCl=\",chgCl,\"numCl=\",numCl,\" numIter=\",numIter,\"\\n Sphere=\",sphere)\n    }    \n  }\n  plot(evalues$values[1:numCl],main=title)\n  \n  return (consMatrixAlg)\n}\n\n\n#######################################\n# Call functions\n#######################################\n\n#The three dataset i've tested this implementation with are:\n# sunspots -> matrix(as.matrix(sunspots),ncol=12,byrow=TRUE))\n# iris[,1:4] -> as.matrix(iris[.1:4])\n# rock -> as.matrix(rock)\n\n#from http://archive.ics.uci.edu/ml/datasets/Turkiye+Student+Evaluation#\nstudent_eval <- read.csv(file=\"turkiye-student-evaluation_R_Specific.csv\", header=TRUE, sep=\",\")\n\n#execute functions\n#execute first analysis on dataset -> be sure to transform it into a matrix for the skmeans to work\n#for some reason sunspots dataset is not transformed properly, it needs to be formatted\nsystem.time(consMatrixAlg <-DatasetAnalysis(as.matrix(iris[.1:4]), datasetName = \"Iris\"))\n\n#execute analysis on Consensus Matrix\n#Indicate if to use the spherical kmeans or the euclidean kmeans (like the glogal sphere flag, TRUE is spherical Kmeans, FALSE euclidean)\nsystem.time(consMatrixAlg<-ConsensusMatrixAnalysis(sphere=TRUE, datasetName = \"Iris\", chgCl=TRUE))\n\n",
    "created" : 1439862251472.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1945207497",
    "id" : "773AB0D4",
    "lastKnownWriteTime" : 1439865047,
    "path" : "~/Documents/DataScientist/NCSU - North Carolina/Courses/Data Mining/Cluster/Ensamble Clustering/ensemble clustering v0.5.R",
    "project_path" : "ensemble clustering v0.5.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}